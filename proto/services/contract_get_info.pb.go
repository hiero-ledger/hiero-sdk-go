//*
// # Contract Get Info
// A standard query to obtain detailed information about a smart contract.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        v5.29.3
// source: contract_get_info.proto

package services

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// Request detailed information about a smart contract.
type ContractGetInfoQuery struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// Standard information sent with every query operation.<br/>
	// This includes the signed payment and what kind of response is requested
	// (cost, state proof, both, or neither).
	Header *QueryHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// *
	// A smart contract ID.
	// <p>
	// The network SHALL return information for this smart contract,
	// if successful.
	ContractID    *ContractID `protobuf:"bytes,2,opt,name=contractID,proto3" json:"contractID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractGetInfoQuery) Reset() {
	*x = ContractGetInfoQuery{}
	mi := &file_contract_get_info_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractGetInfoQuery) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractGetInfoQuery) ProtoMessage() {}

func (x *ContractGetInfoQuery) ProtoReflect() protoreflect.Message {
	mi := &file_contract_get_info_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractGetInfoQuery.ProtoReflect.Descriptor instead.
func (*ContractGetInfoQuery) Descriptor() ([]byte, []int) {
	return file_contract_get_info_proto_rawDescGZIP(), []int{0}
}

func (x *ContractGetInfoQuery) GetHeader() *QueryHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *ContractGetInfoQuery) GetContractID() *ContractID {
	if x != nil {
		return x.ContractID
	}
	return nil
}

// *
// Information returned in response to a "get info" query for a smart contract.
type ContractGetInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The standard response information for queries.<br/>
	// This includes the values requested in the `QueryHeader`
	// (cost, state proof, both, or neither).
	Header *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// *
	// The information, as requested, for a smart contract.
	// A state proof MAY be generated for this value.
	ContractInfo  *ContractGetInfoResponse_ContractInfo `protobuf:"bytes,2,opt,name=contractInfo,proto3" json:"contractInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractGetInfoResponse) Reset() {
	*x = ContractGetInfoResponse{}
	mi := &file_contract_get_info_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractGetInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractGetInfoResponse) ProtoMessage() {}

func (x *ContractGetInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_contract_get_info_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractGetInfoResponse.ProtoReflect.Descriptor instead.
func (*ContractGetInfoResponse) Descriptor() ([]byte, []int) {
	return file_contract_get_info_proto_rawDescGZIP(), []int{1}
}

func (x *ContractGetInfoResponse) GetHeader() *ResponseHeader {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *ContractGetInfoResponse) GetContractInfo() *ContractGetInfoResponse_ContractInfo {
	if x != nil {
		return x.ContractInfo
	}
	return nil
}

type ContractGetInfoResponse_ContractInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The ID of the smart contract requested in the query.
	ContractID *ContractID `protobuf:"bytes,1,opt,name=contractID,proto3" json:"contractID,omitempty"`
	// *
	// The Account ID for the account entry associated with this
	// smart contract.
	AccountID *AccountID `protobuf:"bytes,2,opt,name=accountID,proto3" json:"accountID,omitempty"`
	// *
	// The "Solidity" form contract ID.<br/>
	// This is a hexadecimal string form of the 20-byte EVM address
	// of the contract.
	ContractAccountID string `protobuf:"bytes,3,opt,name=contractAccountID,proto3" json:"contractAccountID,omitempty"`
	// *
	// The key that MUST sign any transaction to update or modify this
	// smart contract.
	// <p>
	// If this value is null, or is an empty `KeyList` then the contract
	// CANNOT be deleted, modified, or updated, but MAY still expire.
	AdminKey *Key `protobuf:"bytes,4,opt,name=adminKey,proto3" json:"adminKey,omitempty"`
	// *
	// The point in time at which this contract will expire.
	ExpirationTime *Timestamp `protobuf:"bytes,5,opt,name=expirationTime,proto3" json:"expirationTime,omitempty"`
	// *
	// The duration, in seconds, for which the contract lifetime will be
	// automatically extended upon expiration, provide sufficient HBAR is
	// available at that time to pay the renewal fee.<br/>
	// See `auto_renew_account_id` for additional conditions.
	AutoRenewPeriod *Duration `protobuf:"bytes,6,opt,name=autoRenewPeriod,proto3" json:"autoRenewPeriod,omitempty"`
	// *
	// The amount of storage used by this smart contract.
	Storage int64 `protobuf:"varint,7,opt,name=storage,proto3" json:"storage,omitempty"`
	// *
	// A short description of this smart contract.
	// <p>
	// This value, if set, MUST NOT exceed `transaction.maxMemoUtf8Bytes`
	// (default 100) bytes when encoded as UTF-8.
	Memo string `protobuf:"bytes,8,opt,name=memo,proto3" json:"memo,omitempty"`
	// *
	// The current HBAR balance, in tinybar, of the smart contract account.
	Balance uint64 `protobuf:"varint,9,opt,name=balance,proto3" json:"balance,omitempty"`
	// *
	// A flag indicating that this contract is deleted.
	Deleted bool `protobuf:"varint,10,opt,name=deleted,proto3" json:"deleted,omitempty"`
	// *
	// Because <a href="https://hips.hedera.com/hip/hip-367">HIP-367</a>,
	// which allows an account to be associated to an unlimited number of
	// tokens, it became necessary to only provide this information from
	// a Mirror Node.<br/>
	// The list of tokens associated to this contract.
	//
	// Deprecated: Marked as deprecated in contract_get_info.proto.
	TokenRelationships []*TokenRelationship `protobuf:"bytes,11,rep,name=tokenRelationships,proto3" json:"tokenRelationships,omitempty"`
	// *
	// The ledger ID of the network that generated this response.
	// <p>
	// This value SHALL identify the distributed ledger that responded to
	// this query.
	LedgerId []byte `protobuf:"bytes,12,opt,name=ledger_id,json=ledgerId,proto3" json:"ledger_id,omitempty"`
	// *
	// An account designated to pay the renewal fee upon automatic renewal
	// of this contract.
	// <p>
	// If this is not set, or is set to an account with zero HBAR
	// available, the HBAR balance of the contract, if available,
	// SHALL be used to pay the renewal fee.
	AutoRenewAccountId *AccountID `protobuf:"bytes,13,opt,name=auto_renew_account_id,json=autoRenewAccountId,proto3" json:"auto_renew_account_id,omitempty"`
	// *
	// The maximum number of tokens that the contract can be
	// associated to automatically.
	MaxAutomaticTokenAssociations int32 `protobuf:"varint,14,opt,name=max_automatic_token_associations,json=maxAutomaticTokenAssociations,proto3" json:"max_automatic_token_associations,omitempty"`
	// *
	// Staking information for this contract.
	StakingInfo   *StakingInfo `protobuf:"bytes,15,opt,name=staking_info,json=stakingInfo,proto3" json:"staking_info,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ContractGetInfoResponse_ContractInfo) Reset() {
	*x = ContractGetInfoResponse_ContractInfo{}
	mi := &file_contract_get_info_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContractGetInfoResponse_ContractInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContractGetInfoResponse_ContractInfo) ProtoMessage() {}

func (x *ContractGetInfoResponse_ContractInfo) ProtoReflect() protoreflect.Message {
	mi := &file_contract_get_info_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContractGetInfoResponse_ContractInfo.ProtoReflect.Descriptor instead.
func (*ContractGetInfoResponse_ContractInfo) Descriptor() ([]byte, []int) {
	return file_contract_get_info_proto_rawDescGZIP(), []int{1, 0}
}

func (x *ContractGetInfoResponse_ContractInfo) GetContractID() *ContractID {
	if x != nil {
		return x.ContractID
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetAccountID() *AccountID {
	if x != nil {
		return x.AccountID
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetContractAccountID() string {
	if x != nil {
		return x.ContractAccountID
	}
	return ""
}

func (x *ContractGetInfoResponse_ContractInfo) GetAdminKey() *Key {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetExpirationTime() *Timestamp {
	if x != nil {
		return x.ExpirationTime
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetAutoRenewPeriod() *Duration {
	if x != nil {
		return x.AutoRenewPeriod
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetStorage() int64 {
	if x != nil {
		return x.Storage
	}
	return 0
}

func (x *ContractGetInfoResponse_ContractInfo) GetMemo() string {
	if x != nil {
		return x.Memo
	}
	return ""
}

func (x *ContractGetInfoResponse_ContractInfo) GetBalance() uint64 {
	if x != nil {
		return x.Balance
	}
	return 0
}

func (x *ContractGetInfoResponse_ContractInfo) GetDeleted() bool {
	if x != nil {
		return x.Deleted
	}
	return false
}

// Deprecated: Marked as deprecated in contract_get_info.proto.
func (x *ContractGetInfoResponse_ContractInfo) GetTokenRelationships() []*TokenRelationship {
	if x != nil {
		return x.TokenRelationships
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetLedgerId() []byte {
	if x != nil {
		return x.LedgerId
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetAutoRenewAccountId() *AccountID {
	if x != nil {
		return x.AutoRenewAccountId
	}
	return nil
}

func (x *ContractGetInfoResponse_ContractInfo) GetMaxAutomaticTokenAssociations() int32 {
	if x != nil {
		return x.MaxAutomaticTokenAssociations
	}
	return 0
}

func (x *ContractGetInfoResponse_ContractInfo) GetStakingInfo() *StakingInfo {
	if x != nil {
		return x.StakingInfo
	}
	return nil
}

var File_contract_get_info_proto protoreflect.FileDescriptor

const file_contract_get_info_proto_rawDesc = "" +
	"\n" +
	"\x17contract_get_info.proto\x12\x05proto\x1a\x0ftimestamp.proto\x1a\x0eduration.proto\x1a\x11basic_types.proto\x1a\x12query_header.proto\x1a\x15response_header.proto\"u\n" +
	"\x14ContractGetInfoQuery\x12*\n" +
	"\x06header\x18\x01 \x01(\v2\x12.proto.QueryHeaderR\x06header\x121\n" +
	"\n" +
	"contractID\x18\x02 \x01(\v2\x11.proto.ContractIDR\n" +
	"contractID\"\xea\x06\n" +
	"\x17ContractGetInfoResponse\x12-\n" +
	"\x06header\x18\x01 \x01(\v2\x15.proto.ResponseHeaderR\x06header\x12O\n" +
	"\fcontractInfo\x18\x02 \x01(\v2+.proto.ContractGetInfoResponse.ContractInfoR\fcontractInfo\x1a\xce\x05\n" +
	"\fContractInfo\x121\n" +
	"\n" +
	"contractID\x18\x01 \x01(\v2\x11.proto.ContractIDR\n" +
	"contractID\x12.\n" +
	"\taccountID\x18\x02 \x01(\v2\x10.proto.AccountIDR\taccountID\x12,\n" +
	"\x11contractAccountID\x18\x03 \x01(\tR\x11contractAccountID\x12&\n" +
	"\badminKey\x18\x04 \x01(\v2\n" +
	".proto.KeyR\badminKey\x128\n" +
	"\x0eexpirationTime\x18\x05 \x01(\v2\x10.proto.TimestampR\x0eexpirationTime\x129\n" +
	"\x0fautoRenewPeriod\x18\x06 \x01(\v2\x0f.proto.DurationR\x0fautoRenewPeriod\x12\x18\n" +
	"\astorage\x18\a \x01(\x03R\astorage\x12\x12\n" +
	"\x04memo\x18\b \x01(\tR\x04memo\x12\x18\n" +
	"\abalance\x18\t \x01(\x04R\abalance\x12\x18\n" +
	"\adeleted\x18\n" +
	" \x01(\bR\adeleted\x12L\n" +
	"\x12tokenRelationships\x18\v \x03(\v2\x18.proto.TokenRelationshipB\x02\x18\x01R\x12tokenRelationships\x12\x1b\n" +
	"\tledger_id\x18\f \x01(\fR\bledgerId\x12C\n" +
	"\x15auto_renew_account_id\x18\r \x01(\v2\x10.proto.AccountIDR\x12autoRenewAccountId\x12G\n" +
	" max_automatic_token_associations\x18\x0e \x01(\x05R\x1dmaxAutomaticTokenAssociations\x125\n" +
	"\fstaking_info\x18\x0f \x01(\v2\x12.proto.StakingInfoR\vstakingInfoB&\n" +
	"\"com.hederahashgraph.api.proto.javaP\x01b\x06proto3"

var (
	file_contract_get_info_proto_rawDescOnce sync.Once
	file_contract_get_info_proto_rawDescData []byte
)

func file_contract_get_info_proto_rawDescGZIP() []byte {
	file_contract_get_info_proto_rawDescOnce.Do(func() {
		file_contract_get_info_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_contract_get_info_proto_rawDesc), len(file_contract_get_info_proto_rawDesc)))
	})
	return file_contract_get_info_proto_rawDescData
}

var file_contract_get_info_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_contract_get_info_proto_goTypes = []any{
	(*ContractGetInfoQuery)(nil),                 // 0: proto.ContractGetInfoQuery
	(*ContractGetInfoResponse)(nil),              // 1: proto.ContractGetInfoResponse
	(*ContractGetInfoResponse_ContractInfo)(nil), // 2: proto.ContractGetInfoResponse.ContractInfo
	(*QueryHeader)(nil),                          // 3: proto.QueryHeader
	(*ContractID)(nil),                           // 4: proto.ContractID
	(*ResponseHeader)(nil),                       // 5: proto.ResponseHeader
	(*AccountID)(nil),                            // 6: proto.AccountID
	(*Key)(nil),                                  // 7: proto.Key
	(*Timestamp)(nil),                            // 8: proto.Timestamp
	(*Duration)(nil),                             // 9: proto.Duration
	(*TokenRelationship)(nil),                    // 10: proto.TokenRelationship
	(*StakingInfo)(nil),                          // 11: proto.StakingInfo
}
var file_contract_get_info_proto_depIdxs = []int32{
	3,  // 0: proto.ContractGetInfoQuery.header:type_name -> proto.QueryHeader
	4,  // 1: proto.ContractGetInfoQuery.contractID:type_name -> proto.ContractID
	5,  // 2: proto.ContractGetInfoResponse.header:type_name -> proto.ResponseHeader
	2,  // 3: proto.ContractGetInfoResponse.contractInfo:type_name -> proto.ContractGetInfoResponse.ContractInfo
	4,  // 4: proto.ContractGetInfoResponse.ContractInfo.contractID:type_name -> proto.ContractID
	6,  // 5: proto.ContractGetInfoResponse.ContractInfo.accountID:type_name -> proto.AccountID
	7,  // 6: proto.ContractGetInfoResponse.ContractInfo.adminKey:type_name -> proto.Key
	8,  // 7: proto.ContractGetInfoResponse.ContractInfo.expirationTime:type_name -> proto.Timestamp
	9,  // 8: proto.ContractGetInfoResponse.ContractInfo.autoRenewPeriod:type_name -> proto.Duration
	10, // 9: proto.ContractGetInfoResponse.ContractInfo.tokenRelationships:type_name -> proto.TokenRelationship
	6,  // 10: proto.ContractGetInfoResponse.ContractInfo.auto_renew_account_id:type_name -> proto.AccountID
	11, // 11: proto.ContractGetInfoResponse.ContractInfo.staking_info:type_name -> proto.StakingInfo
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_contract_get_info_proto_init() }
func file_contract_get_info_proto_init() {
	if File_contract_get_info_proto != nil {
		return
	}
	file_timestamp_proto_init()
	file_duration_proto_init()
	file_basic_types_proto_init()
	file_query_header_proto_init()
	file_response_header_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_contract_get_info_proto_rawDesc), len(file_contract_get_info_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_contract_get_info_proto_goTypes,
		DependencyIndexes: file_contract_get_info_proto_depIdxs,
		MessageInfos:      file_contract_get_info_proto_msgTypes,
	}.Build()
	File_contract_get_info_proto = out.File
	file_contract_get_info_proto_goTypes = nil
	file_contract_get_info_proto_depIdxs = nil
}
