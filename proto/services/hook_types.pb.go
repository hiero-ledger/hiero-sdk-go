// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: hook_types.proto

package services

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// **
// The Hiero extension points that accept a hook.
type HookExtensionPoint int32

const (
	// *
	// Used to customize an account's allowances during a CryptoTransfer transaction.
	HookExtensionPoint_ACCOUNT_ALLOWANCE_HOOK HookExtensionPoint = 0
)

// Enum value maps for HookExtensionPoint.
var (
	HookExtensionPoint_name = map[int32]string{
		0: "ACCOUNT_ALLOWANCE_HOOK",
	}
	HookExtensionPoint_value = map[string]int32{
		"ACCOUNT_ALLOWANCE_HOOK": 0,
	}
)

func (x HookExtensionPoint) Enum() *HookExtensionPoint {
	p := new(HookExtensionPoint)
	*p = x
	return p
}

func (x HookExtensionPoint) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HookExtensionPoint) Descriptor() protoreflect.EnumDescriptor {
	return file_hook_types_proto_enumTypes[0].Descriptor()
}

func (HookExtensionPoint) Type() protoreflect.EnumType {
	return &file_hook_types_proto_enumTypes[0]
}

func (x HookExtensionPoint) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HookExtensionPoint.Descriptor instead.
func (HookExtensionPoint) EnumDescriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{0}
}

// *
// Specifies the creation of a new hook at the given id for the given entity.
type HookCreation struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The id of the hook's entity.
	EntityId *HookEntityId `protobuf:"bytes,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// *
	// The creation details.
	Details *HookCreationDetails `protobuf:"bytes,2,opt,name=details,proto3" json:"details,omitempty"`
	// *
	// If set, the id of the hook following this one in the owner's
	// doubly-linked list of hooks.
	NextHookId    *wrapperspb.Int64Value `protobuf:"bytes,9,opt,name=next_hook_id,json=nextHookId,proto3" json:"next_hook_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HookCreation) Reset() {
	*x = HookCreation{}
	mi := &file_hook_types_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HookCreation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HookCreation) ProtoMessage() {}

func (x *HookCreation) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HookCreation.ProtoReflect.Descriptor instead.
func (*HookCreation) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{0}
}

func (x *HookCreation) GetEntityId() *HookEntityId {
	if x != nil {
		return x.EntityId
	}
	return nil
}

func (x *HookCreation) GetDetails() *HookCreationDetails {
	if x != nil {
		return x.Details
	}
	return nil
}

func (x *HookCreation) GetNextHookId() *wrapperspb.Int64Value {
	if x != nil {
		return x.NextHookId
	}
	return nil
}

// **
// The details of a hook's creation.
type HookCreationDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The extension point for the hook.
	ExtensionPoint HookExtensionPoint `protobuf:"varint,1,opt,name=extension_point,json=extensionPoint,proto3,enum=com.hedera.hapi.node.hooks.HookExtensionPoint" json:"extension_point,omitempty"`
	// *
	// The id to create the hook at.
	HookId int64 `protobuf:"varint,2,opt,name=hook_id,json=hookId,proto3" json:"hook_id,omitempty"`
	// *
	// The hook implementation.
	//
	// Types that are valid to be assigned to Hook:
	//
	//	*HookCreationDetails_LambdaEvmHook
	Hook isHookCreationDetails_Hook `protobuf_oneof:"hook"`
	// *
	// If set, a key that that can be used to remove or replace the hook; or (if
	// applicable, as with a lambda EVM hook) perform transactions that customize
	// the hook.
	AdminKey      *Key `protobuf:"bytes,4,opt,name=admin_key,json=adminKey,proto3" json:"admin_key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HookCreationDetails) Reset() {
	*x = HookCreationDetails{}
	mi := &file_hook_types_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HookCreationDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HookCreationDetails) ProtoMessage() {}

func (x *HookCreationDetails) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HookCreationDetails.ProtoReflect.Descriptor instead.
func (*HookCreationDetails) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{1}
}

func (x *HookCreationDetails) GetExtensionPoint() HookExtensionPoint {
	if x != nil {
		return x.ExtensionPoint
	}
	return HookExtensionPoint_ACCOUNT_ALLOWANCE_HOOK
}

func (x *HookCreationDetails) GetHookId() int64 {
	if x != nil {
		return x.HookId
	}
	return 0
}

func (x *HookCreationDetails) GetHook() isHookCreationDetails_Hook {
	if x != nil {
		return x.Hook
	}
	return nil
}

func (x *HookCreationDetails) GetLambdaEvmHook() *LambdaEvmHook {
	if x != nil {
		if x, ok := x.Hook.(*HookCreationDetails_LambdaEvmHook); ok {
			return x.LambdaEvmHook
		}
	}
	return nil
}

func (x *HookCreationDetails) GetAdminKey() *Key {
	if x != nil {
		return x.AdminKey
	}
	return nil
}

type isHookCreationDetails_Hook interface {
	isHookCreationDetails_Hook()
}

type HookCreationDetails_LambdaEvmHook struct {
	// *
	// A hook programmed in EVM bytecode that may access state or interact with
	// external contracts.
	LambdaEvmHook *LambdaEvmHook `protobuf:"bytes,3,opt,name=lambda_evm_hook,json=lambdaEvmHook,proto3,oneof"`
}

func (*HookCreationDetails_LambdaEvmHook) isHookCreationDetails_Hook() {}

// *
// Definition of a lambda EVM hook.
type LambdaEvmHook struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The specification for the hook.
	Spec *EvmHookSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	// *
	// Initial storage updates for the lambda, if any.
	StorageUpdates []*LambdaStorageUpdate `protobuf:"bytes,2,rep,name=storage_updates,json=storageUpdates,proto3" json:"storage_updates,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *LambdaEvmHook) Reset() {
	*x = LambdaEvmHook{}
	mi := &file_hook_types_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LambdaEvmHook) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LambdaEvmHook) ProtoMessage() {}

func (x *LambdaEvmHook) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LambdaEvmHook.ProtoReflect.Descriptor instead.
func (*LambdaEvmHook) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{2}
}

func (x *LambdaEvmHook) GetSpec() *EvmHookSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *LambdaEvmHook) GetStorageUpdates() []*LambdaStorageUpdate {
	if x != nil {
		return x.StorageUpdates
	}
	return nil
}

// *
// Shared specifications for an EVM hook. May be used for any extension point.
type EvmHookSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The source of the EVM bytecode for the hook.
	//
	// Types that are valid to be assigned to BytecodeSource:
	//
	//	*EvmHookSpec_ContractId
	BytecodeSource isEvmHookSpec_BytecodeSource `protobuf_oneof:"bytecode_source"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *EvmHookSpec) Reset() {
	*x = EvmHookSpec{}
	mi := &file_hook_types_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EvmHookSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EvmHookSpec) ProtoMessage() {}

func (x *EvmHookSpec) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EvmHookSpec.ProtoReflect.Descriptor instead.
func (*EvmHookSpec) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{3}
}

func (x *EvmHookSpec) GetBytecodeSource() isEvmHookSpec_BytecodeSource {
	if x != nil {
		return x.BytecodeSource
	}
	return nil
}

func (x *EvmHookSpec) GetContractId() *ContractID {
	if x != nil {
		if x, ok := x.BytecodeSource.(*EvmHookSpec_ContractId); ok {
			return x.ContractId
		}
	}
	return nil
}

type isEvmHookSpec_BytecodeSource interface {
	isEvmHookSpec_BytecodeSource()
}

type EvmHookSpec_ContractId struct {
	// *
	// The id of a contract that implements the extension point API with EVM bytecode.
	ContractId *ContractID `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3,oneof"`
}

func (*EvmHookSpec_ContractId) isEvmHookSpec_BytecodeSource() {}

// *
// Specifies a key/value pair in the storage of a lambda, either by the explicit storage
// slot contents; or by a combination of a Solidity mapping's slot key and the key into
// that mapping.
type LambdaStorageUpdate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Update:
	//
	//	*LambdaStorageUpdate_StorageSlot
	//	*LambdaStorageUpdate_MappingEntries
	Update        isLambdaStorageUpdate_Update `protobuf_oneof:"update"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LambdaStorageUpdate) Reset() {
	*x = LambdaStorageUpdate{}
	mi := &file_hook_types_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LambdaStorageUpdate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LambdaStorageUpdate) ProtoMessage() {}

func (x *LambdaStorageUpdate) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LambdaStorageUpdate.ProtoReflect.Descriptor instead.
func (*LambdaStorageUpdate) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{4}
}

func (x *LambdaStorageUpdate) GetUpdate() isLambdaStorageUpdate_Update {
	if x != nil {
		return x.Update
	}
	return nil
}

func (x *LambdaStorageUpdate) GetStorageSlot() *LambdaStorageSlot {
	if x != nil {
		if x, ok := x.Update.(*LambdaStorageUpdate_StorageSlot); ok {
			return x.StorageSlot
		}
	}
	return nil
}

func (x *LambdaStorageUpdate) GetMappingEntries() *LambdaMappingEntries {
	if x != nil {
		if x, ok := x.Update.(*LambdaStorageUpdate_MappingEntries); ok {
			return x.MappingEntries
		}
	}
	return nil
}

type isLambdaStorageUpdate_Update interface {
	isLambdaStorageUpdate_Update()
}

type LambdaStorageUpdate_StorageSlot struct {
	// *
	// An explicit storage slot update.
	StorageSlot *LambdaStorageSlot `protobuf:"bytes,1,opt,name=storage_slot,json=storageSlot,proto3,oneof"`
}

type LambdaStorageUpdate_MappingEntries struct {
	// *
	// Implicit storage slot updates specified as Solidity mapping entries.
	MappingEntries *LambdaMappingEntries `protobuf:"bytes,2,opt,name=mapping_entries,json=mappingEntries,proto3,oneof"`
}

func (*LambdaStorageUpdate_StorageSlot) isLambdaStorageUpdate_Update() {}

func (*LambdaStorageUpdate_MappingEntries) isLambdaStorageUpdate_Update() {}

// *
// Specifies storage slot updates via indirection into a Solidity mapping.
// <p>
// Concretely, if the Solidity mapping is itself at slot `mapping_slot`, then
// the * storage slot for key `key` in the mapping is defined by the relationship
// `key_storage_slot = keccak256(abi.encodePacked(mapping_slot, key))`.
// <p>
// This message lets a metaprotocol be specified in terms of changes to a
// Solidity mapping's entries. If only raw slots could be updated, then a block
// stream consumer following the metaprotocol would have to invert the Keccak256
// hash to determine which mapping entry was being updated, which is not possible.
type LambdaMappingEntries struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The slot that corresponds to the Solidity mapping itself. Must use a
	// minimal byte representation (no leading zeros).
	MappingSlot []byte `protobuf:"bytes,1,opt,name=mapping_slot,json=mappingSlot,proto3" json:"mapping_slot,omitempty"`
	// *
	// The entries in the mapping at the given slot.
	Entries       []*LambdaMappingEntry `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LambdaMappingEntries) Reset() {
	*x = LambdaMappingEntries{}
	mi := &file_hook_types_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LambdaMappingEntries) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LambdaMappingEntries) ProtoMessage() {}

func (x *LambdaMappingEntries) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LambdaMappingEntries.ProtoReflect.Descriptor instead.
func (*LambdaMappingEntries) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{5}
}

func (x *LambdaMappingEntries) GetMappingSlot() []byte {
	if x != nil {
		return x.MappingSlot
	}
	return nil
}

func (x *LambdaMappingEntries) GetEntries() []*LambdaMappingEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// *
// An entry in a Solidity mapping. Very helpful for protocols that apply
// `LambdaSStore` to manage the entries of a hook contract's mapping instead
// its raw storage slots.
// <p>
// This is especially attractive when the mapping value itself fits in a single
// word; for more complicated value storage layouts it becomes necessary to
// combine the mapping update with additional `LambdaStorageSlot` updates that
// specify the complete storage slots of the value type.
type LambdaMappingEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to EntryKey:
	//
	//	*LambdaMappingEntry_Key
	//	*LambdaMappingEntry_Preimage
	EntryKey isLambdaMappingEntry_EntryKey `protobuf_oneof:"entry_key"`
	// *
	// If the mapping entry is present and non-zero, its value. May not be longer than
	// 32 bytes in length; must use a minimal byte representation (no leading zeros).
	// Leaving this field empty in an update removes the entry from the mapping.
	Value         []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LambdaMappingEntry) Reset() {
	*x = LambdaMappingEntry{}
	mi := &file_hook_types_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LambdaMappingEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LambdaMappingEntry) ProtoMessage() {}

func (x *LambdaMappingEntry) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LambdaMappingEntry.ProtoReflect.Descriptor instead.
func (*LambdaMappingEntry) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{6}
}

func (x *LambdaMappingEntry) GetEntryKey() isLambdaMappingEntry_EntryKey {
	if x != nil {
		return x.EntryKey
	}
	return nil
}

func (x *LambdaMappingEntry) GetKey() []byte {
	if x != nil {
		if x, ok := x.EntryKey.(*LambdaMappingEntry_Key); ok {
			return x.Key
		}
	}
	return nil
}

func (x *LambdaMappingEntry) GetPreimage() []byte {
	if x != nil {
		if x, ok := x.EntryKey.(*LambdaMappingEntry_Preimage); ok {
			return x.Preimage
		}
	}
	return nil
}

func (x *LambdaMappingEntry) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

type isLambdaMappingEntry_EntryKey interface {
	isLambdaMappingEntry_EntryKey()
}

type LambdaMappingEntry_Key struct {
	// *
	// The explicit bytes of the mapping entry. Must use a minimal byte representation;
	// may not exceed 32 bytes in length.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3,oneof"`
}

type LambdaMappingEntry_Preimage struct {
	// *
	// The bytes that are the preimage of the Keccak256 hash that forms the mapping key.
	// May be longer or shorter than 32 bytes and may have leading zeros, since Solidity
	// supports variable-length keys in mappings.
	Preimage []byte `protobuf:"bytes,2,opt,name=preimage,proto3,oneof"`
}

func (*LambdaMappingEntry_Key) isLambdaMappingEntry_EntryKey() {}

func (*LambdaMappingEntry_Preimage) isLambdaMappingEntry_EntryKey() {}

// *
// A slot in the storage of a lambda EVM hook.
type LambdaStorageSlot struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The key of the slot. Must use a minimal byte representation (no
	// leading zeros); may not exceed 32 bytes in length.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// *
	// If the slot is present and non-zero, its value. Must use a minimal
	// byte representation (no leading zeros); may not exceed 32 bytes in
	// length Leaving this field empty in an update removes the slot from
	// storage.
	Value         []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LambdaStorageSlot) Reset() {
	*x = LambdaStorageSlot{}
	mi := &file_hook_types_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LambdaStorageSlot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LambdaStorageSlot) ProtoMessage() {}

func (x *LambdaStorageSlot) ProtoReflect() protoreflect.Message {
	mi := &file_hook_types_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LambdaStorageSlot.ProtoReflect.Descriptor instead.
func (*LambdaStorageSlot) Descriptor() ([]byte, []int) {
	return file_hook_types_proto_rawDescGZIP(), []int{7}
}

func (x *LambdaStorageSlot) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *LambdaStorageSlot) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

var File_hook_types_proto protoreflect.FileDescriptor

const file_hook_types_proto_rawDesc = "" +
	"\n" +
	"\x10hook_types.proto\x12\x1acom.hedera.hapi.node.hooks\x1a\x11basic_types.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\xca\x01\n" +
	"\fHookCreation\x120\n" +
	"\tentity_id\x18\x01 \x01(\v2\x13.proto.HookEntityIdR\bentityId\x12I\n" +
	"\adetails\x18\x02 \x01(\v2/.com.hedera.hapi.node.hooks.HookCreationDetailsR\adetails\x12=\n" +
	"\fnext_hook_id\x18\t \x01(\v2\x1b.google.protobuf.Int64ValueR\n" +
	"nextHookId\"\x8d\x02\n" +
	"\x13HookCreationDetails\x12W\n" +
	"\x0fextension_point\x18\x01 \x01(\x0e2..com.hedera.hapi.node.hooks.HookExtensionPointR\x0eextensionPoint\x12\x17\n" +
	"\ahook_id\x18\x02 \x01(\x03R\x06hookId\x12S\n" +
	"\x0flambda_evm_hook\x18\x03 \x01(\v2).com.hedera.hapi.node.hooks.LambdaEvmHookH\x00R\rlambdaEvmHook\x12'\n" +
	"\tadmin_key\x18\x04 \x01(\v2\n" +
	".proto.KeyR\badminKeyB\x06\n" +
	"\x04hook\"\xa6\x01\n" +
	"\rLambdaEvmHook\x12;\n" +
	"\x04spec\x18\x01 \x01(\v2'.com.hedera.hapi.node.hooks.EvmHookSpecR\x04spec\x12X\n" +
	"\x0fstorage_updates\x18\x02 \x03(\v2/.com.hedera.hapi.node.hooks.LambdaStorageUpdateR\x0estorageUpdates\"V\n" +
	"\vEvmHookSpec\x124\n" +
	"\vcontract_id\x18\x01 \x01(\v2\x11.proto.ContractIDH\x00R\n" +
	"contractIdB\x11\n" +
	"\x0fbytecode_source\"\xd0\x01\n" +
	"\x13LambdaStorageUpdate\x12R\n" +
	"\fstorage_slot\x18\x01 \x01(\v2-.com.hedera.hapi.node.hooks.LambdaStorageSlotH\x00R\vstorageSlot\x12[\n" +
	"\x0fmapping_entries\x18\x02 \x01(\v20.com.hedera.hapi.node.hooks.LambdaMappingEntriesH\x00R\x0emappingEntriesB\b\n" +
	"\x06update\"\x83\x01\n" +
	"\x14LambdaMappingEntries\x12!\n" +
	"\fmapping_slot\x18\x01 \x01(\fR\vmappingSlot\x12H\n" +
	"\aentries\x18\x02 \x03(\v2..com.hedera.hapi.node.hooks.LambdaMappingEntryR\aentries\"i\n" +
	"\x12LambdaMappingEntry\x12\x12\n" +
	"\x03key\x18\x01 \x01(\fH\x00R\x03key\x12\x1c\n" +
	"\bpreimage\x18\x02 \x01(\fH\x00R\bpreimage\x12\x14\n" +
	"\x05value\x18\x03 \x01(\fR\x05valueB\v\n" +
	"\tentry_key\";\n" +
	"\x11LambdaStorageSlot\x12\x10\n" +
	"\x03key\x18\x01 \x01(\fR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\fR\x05value*0\n" +
	"\x12HookExtensionPoint\x12\x1a\n" +
	"\x16ACCOUNT_ALLOWANCE_HOOK\x10\x00B%\n" +
	"!com.hedera.hapi.node.hooks.legacyP\x01b\x06proto3"

var (
	file_hook_types_proto_rawDescOnce sync.Once
	file_hook_types_proto_rawDescData []byte
)

func file_hook_types_proto_rawDescGZIP() []byte {
	file_hook_types_proto_rawDescOnce.Do(func() {
		file_hook_types_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_hook_types_proto_rawDesc), len(file_hook_types_proto_rawDesc)))
	})
	return file_hook_types_proto_rawDescData
}

var file_hook_types_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_hook_types_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_hook_types_proto_goTypes = []any{
	(HookExtensionPoint)(0),       // 0: com.hedera.hapi.node.hooks.HookExtensionPoint
	(*HookCreation)(nil),          // 1: com.hedera.hapi.node.hooks.HookCreation
	(*HookCreationDetails)(nil),   // 2: com.hedera.hapi.node.hooks.HookCreationDetails
	(*LambdaEvmHook)(nil),         // 3: com.hedera.hapi.node.hooks.LambdaEvmHook
	(*EvmHookSpec)(nil),           // 4: com.hedera.hapi.node.hooks.EvmHookSpec
	(*LambdaStorageUpdate)(nil),   // 5: com.hedera.hapi.node.hooks.LambdaStorageUpdate
	(*LambdaMappingEntries)(nil),  // 6: com.hedera.hapi.node.hooks.LambdaMappingEntries
	(*LambdaMappingEntry)(nil),    // 7: com.hedera.hapi.node.hooks.LambdaMappingEntry
	(*LambdaStorageSlot)(nil),     // 8: com.hedera.hapi.node.hooks.LambdaStorageSlot
	(*HookEntityId)(nil),          // 9: proto.HookEntityId
	(*wrapperspb.Int64Value)(nil), // 10: google.protobuf.Int64Value
	(*Key)(nil),                   // 11: proto.Key
	(*ContractID)(nil),            // 12: proto.ContractID
}
var file_hook_types_proto_depIdxs = []int32{
	9,  // 0: com.hedera.hapi.node.hooks.HookCreation.entity_id:type_name -> proto.HookEntityId
	2,  // 1: com.hedera.hapi.node.hooks.HookCreation.details:type_name -> com.hedera.hapi.node.hooks.HookCreationDetails
	10, // 2: com.hedera.hapi.node.hooks.HookCreation.next_hook_id:type_name -> google.protobuf.Int64Value
	0,  // 3: com.hedera.hapi.node.hooks.HookCreationDetails.extension_point:type_name -> com.hedera.hapi.node.hooks.HookExtensionPoint
	3,  // 4: com.hedera.hapi.node.hooks.HookCreationDetails.lambda_evm_hook:type_name -> com.hedera.hapi.node.hooks.LambdaEvmHook
	11, // 5: com.hedera.hapi.node.hooks.HookCreationDetails.admin_key:type_name -> proto.Key
	4,  // 6: com.hedera.hapi.node.hooks.LambdaEvmHook.spec:type_name -> com.hedera.hapi.node.hooks.EvmHookSpec
	5,  // 7: com.hedera.hapi.node.hooks.LambdaEvmHook.storage_updates:type_name -> com.hedera.hapi.node.hooks.LambdaStorageUpdate
	12, // 8: com.hedera.hapi.node.hooks.EvmHookSpec.contract_id:type_name -> proto.ContractID
	8,  // 9: com.hedera.hapi.node.hooks.LambdaStorageUpdate.storage_slot:type_name -> com.hedera.hapi.node.hooks.LambdaStorageSlot
	6,  // 10: com.hedera.hapi.node.hooks.LambdaStorageUpdate.mapping_entries:type_name -> com.hedera.hapi.node.hooks.LambdaMappingEntries
	7,  // 11: com.hedera.hapi.node.hooks.LambdaMappingEntries.entries:type_name -> com.hedera.hapi.node.hooks.LambdaMappingEntry
	12, // [12:12] is the sub-list for method output_type
	12, // [12:12] is the sub-list for method input_type
	12, // [12:12] is the sub-list for extension type_name
	12, // [12:12] is the sub-list for extension extendee
	0,  // [0:12] is the sub-list for field type_name
}

func init() { file_hook_types_proto_init() }
func file_hook_types_proto_init() {
	if File_hook_types_proto != nil {
		return
	}
	file_basic_types_proto_init()
	file_hook_types_proto_msgTypes[1].OneofWrappers = []any{
		(*HookCreationDetails_LambdaEvmHook)(nil),
	}
	file_hook_types_proto_msgTypes[3].OneofWrappers = []any{
		(*EvmHookSpec_ContractId)(nil),
	}
	file_hook_types_proto_msgTypes[4].OneofWrappers = []any{
		(*LambdaStorageUpdate_StorageSlot)(nil),
		(*LambdaStorageUpdate_MappingEntries)(nil),
	}
	file_hook_types_proto_msgTypes[6].OneofWrappers = []any{
		(*LambdaMappingEntry_Key)(nil),
		(*LambdaMappingEntry_Preimage)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_hook_types_proto_rawDesc), len(file_hook_types_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   8,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_hook_types_proto_goTypes,
		DependencyIndexes: file_hook_types_proto_depIdxs,
		EnumInfos:         file_hook_types_proto_enumTypes,
		MessageInfos:      file_hook_types_proto_msgTypes,
	}.Build()
	File_hook_types_proto = out.File
	file_hook_types_proto_goTypes = nil
	file_hook_types_proto_depIdxs = nil
}
