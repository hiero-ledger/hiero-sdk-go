//*
// # Custom Fees
// Fees defined by token creators that are charged as part of each
// transfer of that token type.
//
// ### Keywords
// The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
// "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
// document are to be interpreted as described in
// [RFC2119](https://www.ietf.org/rfc/rfc2119) and clarified in
// [RFC8174](https://www.ietf.org/rfc/rfc8174).

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: custom_fees.proto

package services

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *
// A descriptor for a fee based on a portion of the tokens transferred.
//
// This fee option describes fees as a fraction of the amount of
// fungible/common token(s) transferred.  The fee also describes a minimum
// and maximum amount, both of which are OPTIONAL.
//
// This type of fee SHALL be assessed only for fungible/common tokens.<br/>
// This type of fee MUST NOT be defined for a non-fungible/unique
// token type.<br/>
// This fee SHALL be paid with the same type of tokens as those
// transferred.<br/>
// The fee MAY be subtracted from the transferred tokens, or MAY be assessed
// to the sender in addition to the tokens actually transferred, based on
// the `net_of_transfers` field.
//
// When a single transaction sends tokens from one sender to multiple
// recipients, and the `net_of_transfers` flag is false, the network
// SHALL attempt to evenly assess the total fee across all recipients
// proportionally. This may be inexact and, particularly when there are
// large differences between recipients, MAY result in small deviations
// from an ideal "fair" distribution.<br/>
// If the sender lacks sufficient tokens to pay fees, or the assessment
// of custom fees reduces the net amount transferred to or below zero,
// the transaction MAY fail due to insufficient funds to pay all fees.
type FractionalFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A Fraction of the transferred tokens to assess as a fee.<br/>
	// This value MUST be less than or equal to one.<br/>
	// This value MUST be greater than zero.
	FractionalAmount *Fraction `protobuf:"bytes,1,opt,name=fractional_amount,json=fractionalAmount,proto3" json:"fractional_amount,omitempty"`
	// *
	// A minimum fee to charge, in units of 10<sup>-decimals</sup> tokens.
	// <p>
	// This value is OPTIONAL, with a default of `0` indicating no minimum.<br/>
	// If set, this value MUST be greater than zero.<br/>
	// If set, all transfers SHALL pay at least this amount.
	MinimumAmount int64 `protobuf:"varint,2,opt,name=minimum_amount,json=minimumAmount,proto3" json:"minimum_amount,omitempty"`
	// *
	// A maximum fee to charge, in units of 10<sup>-decimals</sup> tokens.
	// <p>
	// This value is OPTIONAL, with a default of `0` indicating no maximum.<br/>
	// If set, this value MUST be greater than zero.<br/>
	// If set, any fee charged SHALL NOT exceed this value.<br/>
	// This value SHOULD be strictly greater than `minimum_amount`.
	// If this amount is less than or equal to `minimum_amount`, then
	// the fee charged SHALL always be equal to this value and
	// `fractional_amount` SHALL NOT have any effect.
	MaximumAmount int64 `protobuf:"varint,3,opt,name=maximum_amount,json=maximumAmount,proto3" json:"maximum_amount,omitempty"`
	// *
	// Flag requesting to assess the calculated fee against the sender,
	// without reducing the amount transferred.<br/>
	// #### Effects of this flag
	// <ol>
	//
	//	<li>If this value is true
	//	  <ul>
	//	    <li>The receiver of a transfer SHALL receive the entire
	//	        amount sent.</li>
	//	    <li>The fee SHALL be charged to the sender as an additional
	//	        amount, increasing the token transfer debit.</li>
	//	  </ul>
	//	</li>
	//	<li>If this value is false
	//	  <ul>
	//	    <li>The receiver of a transfer SHALL receive the amount sent
	//	        _after_ deduction of the calculated fee.</li>
	//	  </ul>
	//	</li>
	//
	// </ol>
	NetOfTransfers bool `protobuf:"varint,4,opt,name=net_of_transfers,json=netOfTransfers,proto3" json:"net_of_transfers,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *FractionalFee) Reset() {
	*x = FractionalFee{}
	mi := &file_custom_fees_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FractionalFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FractionalFee) ProtoMessage() {}

func (x *FractionalFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FractionalFee.ProtoReflect.Descriptor instead.
func (*FractionalFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{0}
}

func (x *FractionalFee) GetFractionalAmount() *Fraction {
	if x != nil {
		return x.FractionalAmount
	}
	return nil
}

func (x *FractionalFee) GetMinimumAmount() int64 {
	if x != nil {
		return x.MinimumAmount
	}
	return 0
}

func (x *FractionalFee) GetMaximumAmount() int64 {
	if x != nil {
		return x.MaximumAmount
	}
	return 0
}

func (x *FractionalFee) GetNetOfTransfers() bool {
	if x != nil {
		return x.NetOfTransfers
	}
	return false
}

// *
// A fixed fee to assess for each token transfer, regardless of the
// amount transferred.<br/>
// This fee type describes a fixed fee for each transfer of a token type.
//
// The fee SHALL be charged to the `sender` for the token transfer
// transaction.<br/>
// This fee MAY be assessed in HBAR, the token type transferred, or any
// other token type, as determined by the `denominating_token_id` field.
type FixedFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The amount to assess for each transfer.
	// <p>
	// This value MUST be greater than `0`.<br/>
	// This amount is expressed in units of 10<sup>-decimals</sup> tokens.
	Amount int64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// *
	// The token type used to pay the assessed fee.
	// <p>
	// If this is unset, the fee SHALL be assessed in HBAR.<br/>
	// If this is set, the fee SHALL be assessed in the token identified.
	// This MAY be any token type. Custom fees assessed in other token types
	// are more likely to fail, however, and it is RECOMMENDED that token
	// creators denominate custom fees in the transferred token, HBAR, or
	// well documented and closely related token types.<br/>
	// If this value is set to `0.0.0` in the `tokenCreate` transaction, it
	// SHALL be replaced with the `TokenID` of the newly created token.
	DenominatingTokenId *TokenID `protobuf:"bytes,2,opt,name=denominating_token_id,json=denominatingTokenId,proto3" json:"denominating_token_id,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *FixedFee) Reset() {
	*x = FixedFee{}
	mi := &file_custom_fees_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FixedFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FixedFee) ProtoMessage() {}

func (x *FixedFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FixedFee.ProtoReflect.Descriptor instead.
func (*FixedFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{1}
}

func (x *FixedFee) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *FixedFee) GetDenominatingTokenId() *TokenID {
	if x != nil {
		return x.DenominatingTokenId
	}
	return nil
}

// *
// A fee to assess during a CryptoTransfer that changes ownership of a
// non-fungible/unique (NFT) token.<br/>
// This message defines the fraction of the fungible value exchanged for an
// NFT that the ledger should collect as a royalty.
// "Fungible value" includes both HBAR (â„) and units of fungible HTS tokens.
// When the NFT sender does not receive any fungible value, the ledger will
// assess the fallback fee, if present, to the new NFT owner. Royalty fees
// can only be added to non-fungible/unique tokens.
//
// #### Important Note
// > Users should be aware that native royalty fees are _strictly_ a
// > convenience feature, SHALL NOT be guaranteed, and the network SHALL NOT
// > enforce _inescapable_ royalties on the exchange of a unique NFT.<br/>
// > For _one_ example, if the counterparties agree to split their value
// > transfer and NFT exchange into separate transactions, the network cannot
// > possibly determine the value exchanged. Even trustless transactions,
// > using a smart contract or other form of escrow, can arrange such split
// > transactions as a single _logical_ transfer.
//
// Counterparties that wish to _respect_ creator royalties MUST follow the
// pattern the network recognizes.
// <div style="margin-left: 2em; margin-top: -0.8em">
// A single transaction MUST contain all three elements, transfer of the NFT,
// debit of fungible value from the receiver, and credit of fungible value to
// the sender, in order for the network to accurately assess royalty fees.
// </div>
// <div style="margin-left: 1em; margin-top: -0.8em">
// Two examples are presented here.
// <div style="margin-left: 1em">
// The NFT sender and receiver MUST both sign a single `cryptoTransfer` that
// transfers the NFT from sender to receiver, debits the fungible value from
// the receiver, and credits the sender with the fungible value the receiver
// is exchanging for the NFT.<br/>
// A marketplace using an approved spender account for an escrow transaction
// MUST credit the account selling the NFT in the same `cryptoTransfer`
// transaction that transfers the NFT to, and deducts fungible value from,
// the buying account.
// </div></div>
// This type of fee MAY NOT produce accurate results if multiple transfers
// are executed in a single transaction. It is RECOMMENDED that each
// NFT subject to royalty fees be transferred separately and without
// unrelated fungible token transfers.
//
// The network SHALL NOT consider third-party transfers, including
// "approved spender" accounts, in collecting royalty fees. An honest
// broker MUST ensure that transfer of an NFT and payment delivered to
// the sender are present in the same transaction.
// There is an
// [open suggestion](https://github.com/hashgraph/hedera-improvement-proposal/discussions/578)
// that proposes to broaden the scope of transfers from which the network
// automatically collects royalties to cover related third parties. If this
// interests or concerns you, please add your voice to that discussion.
type RoyaltyFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// The fraction of fungible value exchanged for an NFT to collect
	// as royalty.
	// <p>
	// This SHALL be applied once to the total fungible value transferred
	// for the transaction.<br/>
	// There SHALL NOT be any adjustment based on multiple transfers
	// involving the NFT sender as part of a single transaction.
	ExchangeValueFraction *Fraction `protobuf:"bytes,1,opt,name=exchange_value_fraction,json=exchangeValueFraction,proto3" json:"exchange_value_fraction,omitempty"`
	// *
	// A fixed fee to assess if no fungible value is known to be traded
	// for the NFT.
	// <p>
	// If an NFT is transferred without a corresponding transfer of
	// _fungible_ value returned in the same transaction, the network
	// SHALL charge this fee as a fallback.<br/>
	// Fallback fees MAY have unexpected effects when interacting with
	// escrow, market transfers, and smart contracts.
	// It is RECOMMENDED that developers carefully consider possible
	// effects from fallback fees when designing systems that facilitate
	// the transfer of NFTs.
	FallbackFee   *FixedFee `protobuf:"bytes,2,opt,name=fallback_fee,json=fallbackFee,proto3" json:"fallback_fee,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RoyaltyFee) Reset() {
	*x = RoyaltyFee{}
	mi := &file_custom_fees_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RoyaltyFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RoyaltyFee) ProtoMessage() {}

func (x *RoyaltyFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RoyaltyFee.ProtoReflect.Descriptor instead.
func (*RoyaltyFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{2}
}

func (x *RoyaltyFee) GetExchangeValueFraction() *Fraction {
	if x != nil {
		return x.ExchangeValueFraction
	}
	return nil
}

func (x *RoyaltyFee) GetFallbackFee() *FixedFee {
	if x != nil {
		return x.FallbackFee
	}
	return nil
}

// *
// A transfer fee to assess during a CryptoTransfer.<br/>
// This fee applies to transactions that transfer units of the token to
// which the fee is attached. A custom fee may be either fixed or fractional,
// and must specify a fee collector account to receive the assessed fees.
//
// Custom fees MUST be greater than zero (0).
type CustomFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Fee:
	//
	//	*CustomFee_FixedFee
	//	*CustomFee_FractionalFee
	//	*CustomFee_RoyaltyFee
	Fee isCustomFee_Fee `protobuf_oneof:"fee"`
	// *
	// The account to receive the custom fee.
	FeeCollectorAccountId *AccountID `protobuf:"bytes,3,opt,name=fee_collector_account_id,json=feeCollectorAccountId,proto3" json:"fee_collector_account_id,omitempty"`
	// *
	// Flag indicating to exempt all custom fee collector accounts for this
	// token type from paying this custom fee when sending tokens.
	// <p>
	// The treasury account for a token, and the account identified by the
	// `fee_collector_account_id` field of this `CustomFee` are always exempt
	// from this custom fee to avoid redundant and unnecessary transfers.
	// If this value is `true` then the account(s) identified in
	// `fee_collector_account_id` for _all_ custom fee definitions for this
	// token type SHALL also be exempt from this custom fee.
	// This behavior is specified in HIP-573.
	AllCollectorsAreExempt bool `protobuf:"varint,5,opt,name=all_collectors_are_exempt,json=allCollectorsAreExempt,proto3" json:"all_collectors_are_exempt,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *CustomFee) Reset() {
	*x = CustomFee{}
	mi := &file_custom_fees_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomFee) ProtoMessage() {}

func (x *CustomFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CustomFee.ProtoReflect.Descriptor instead.
func (*CustomFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{3}
}

func (x *CustomFee) GetFee() isCustomFee_Fee {
	if x != nil {
		return x.Fee
	}
	return nil
}

func (x *CustomFee) GetFixedFee() *FixedFee {
	if x != nil {
		if x, ok := x.Fee.(*CustomFee_FixedFee); ok {
			return x.FixedFee
		}
	}
	return nil
}

func (x *CustomFee) GetFractionalFee() *FractionalFee {
	if x != nil {
		if x, ok := x.Fee.(*CustomFee_FractionalFee); ok {
			return x.FractionalFee
		}
	}
	return nil
}

func (x *CustomFee) GetRoyaltyFee() *RoyaltyFee {
	if x != nil {
		if x, ok := x.Fee.(*CustomFee_RoyaltyFee); ok {
			return x.RoyaltyFee
		}
	}
	return nil
}

func (x *CustomFee) GetFeeCollectorAccountId() *AccountID {
	if x != nil {
		return x.FeeCollectorAccountId
	}
	return nil
}

func (x *CustomFee) GetAllCollectorsAreExempt() bool {
	if x != nil {
		return x.AllCollectorsAreExempt
	}
	return false
}

type isCustomFee_Fee interface {
	isCustomFee_Fee()
}

type CustomFee_FixedFee struct {
	// *
	// A fixed fee to be charged to the `sender` for every token transfer.
	// <p>
	// This type of fee MAY be defined for any token type.<br/>
	// This type of fee MAY be more consistent and reliable than
	// other types.
	FixedFee *FixedFee `protobuf:"bytes,1,opt,name=fixed_fee,json=fixedFee,proto3,oneof"`
}

type CustomFee_FractionalFee struct {
	// *
	// A fee defined as a fraction of the tokens transferred.
	// <p>
	// This type of fee MUST NOT be defined for a non-fungible/unique
	// token type.<br/>
	// This fee MAY be charged to either sender, as an increase to the
	// amount sent, or receiver, as a reduction to the amount received.
	FractionalFee *FractionalFee `protobuf:"bytes,2,opt,name=fractional_fee,json=fractionalFee,proto3,oneof"`
}

type CustomFee_RoyaltyFee struct {
	// *
	// A fee charged as royalty for any transfer of a
	// non-fungible/unique token.
	// <p>
	// This type of fee MUST NOT be defined for a
	// fungible/common token type.
	RoyaltyFee *RoyaltyFee `protobuf:"bytes,4,opt,name=royalty_fee,json=royaltyFee,proto3,oneof"`
}

func (*CustomFee_FixedFee) isCustomFee_Fee() {}

func (*CustomFee_FractionalFee) isCustomFee_Fee() {}

func (*CustomFee_RoyaltyFee) isCustomFee_Fee() {}

// *
// Description of a transfer added to a `cryptoTransfer` transaction that
// satisfies custom fee requirements.
//
// It is important to note that this is not the actual transfer. The transfer
// of value SHALL be merged into the original transaction to minimize the
// number of actual transfers. This descriptor presents the fee assessed
// separately in the record stream so that the details of the fee assessed
// are not hidden in this process.
type AssessedCustomFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// An amount of tokens assessed for this custom fee.
	// <p>
	// This shall be expressed in units of 10<sup>-decimals</sup> tokens.
	Amount int64 `protobuf:"varint,1,opt,name=amount,proto3" json:"amount,omitempty"`
	// *
	// The token transferred to satisfy this fee.
	// <p>
	// If the token transferred is HBAR, this field SHALL NOT be set.
	TokenId *TokenID `protobuf:"bytes,2,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	// *
	// An account that received the fee assessed.
	// <p>
	// This SHALL NOT be the sender or receiver of the original
	// cryptoTransfer transaction.
	FeeCollectorAccountId *AccountID `protobuf:"bytes,3,opt,name=fee_collector_account_id,json=feeCollectorAccountId,proto3" json:"fee_collector_account_id,omitempty"`
	// *
	// An account that provided the tokens assessed as a fee.
	// <p>
	// This SHALL be the account that _would have_ had a higher balance
	// absent the fee. In most cases this SHALL be the `sender`, but
	// some _fractional_ fees reduce the amount transferred, and in those
	// cases the `receiver` SHALL be the effective payer for the fee.<br/>
	// There are currently no situations where a third party pays a custom
	// fee. This MAY change in a future release.
	EffectivePayerAccountId []*AccountID `protobuf:"bytes,4,rep,name=effective_payer_account_id,json=effectivePayerAccountId,proto3" json:"effective_payer_account_id,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *AssessedCustomFee) Reset() {
	*x = AssessedCustomFee{}
	mi := &file_custom_fees_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AssessedCustomFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AssessedCustomFee) ProtoMessage() {}

func (x *AssessedCustomFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AssessedCustomFee.ProtoReflect.Descriptor instead.
func (*AssessedCustomFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{4}
}

func (x *AssessedCustomFee) GetAmount() int64 {
	if x != nil {
		return x.Amount
	}
	return 0
}

func (x *AssessedCustomFee) GetTokenId() *TokenID {
	if x != nil {
		return x.TokenId
	}
	return nil
}

func (x *AssessedCustomFee) GetFeeCollectorAccountId() *AccountID {
	if x != nil {
		return x.FeeCollectorAccountId
	}
	return nil
}

func (x *AssessedCustomFee) GetEffectivePayerAccountId() []*AccountID {
	if x != nil {
		return x.EffectivePayerAccountId
	}
	return nil
}

// *
// A custom fee definition for a consensus topic.
// <p>
// This fee definition is specific to an Hedera Consensus Service (HCS) topic
// and SHOULD NOT be used in any other context.<br/>
// All fields for this message are REQUIRED.<br/>
// Only "fixed" fee definitions are supported because there is no basis for
// a fractional fee on a consensus submit transaction.
type FixedCustomFee struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A fixed custom fee.
	// <p>
	// The amount of HBAR or other token described by this `FixedFee` SHALL
	// be charged to the transction payer for each message submitted to a
	// topic that assigns this consensus custom fee.
	FixedFee *FixedFee `protobuf:"bytes,1,opt,name=fixed_fee,json=fixedFee,proto3" json:"fixed_fee,omitempty"`
	// *
	// A collection account identifier.
	// <p>
	// All amounts collected for this consensus custom fee SHALL be transferred
	// to the account identified by this field.
	FeeCollectorAccountId *AccountID `protobuf:"bytes,2,opt,name=fee_collector_account_id,json=feeCollectorAccountId,proto3" json:"fee_collector_account_id,omitempty"`
	unknownFields         protoimpl.UnknownFields
	sizeCache             protoimpl.SizeCache
}

func (x *FixedCustomFee) Reset() {
	*x = FixedCustomFee{}
	mi := &file_custom_fees_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FixedCustomFee) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FixedCustomFee) ProtoMessage() {}

func (x *FixedCustomFee) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FixedCustomFee.ProtoReflect.Descriptor instead.
func (*FixedCustomFee) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{5}
}

func (x *FixedCustomFee) GetFixedFee() *FixedFee {
	if x != nil {
		return x.FixedFee
	}
	return nil
}

func (x *FixedCustomFee) GetFeeCollectorAccountId() *AccountID {
	if x != nil {
		return x.FeeCollectorAccountId
	}
	return nil
}

// *
// A wrapper around a consensus custom fee list.<br/>
// This wrapper exists to enable an update transaction to differentiate between
//
//	a field that is not set and an empty list of custom fees.
//
// <p>
// An _unset_ field of this type SHALL NOT modify existing values.<br/>
// A _set_ field of this type with an empty `fees` list SHALL remove any
//
//	existing values.
type FixedCustomFeeList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A set of custom fee definitions.<br/>
	// These are fees to be assessed for each submit to a topic.
	Fees          []*FixedCustomFee `protobuf:"bytes,1,rep,name=fees,proto3" json:"fees,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FixedCustomFeeList) Reset() {
	*x = FixedCustomFeeList{}
	mi := &file_custom_fees_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FixedCustomFeeList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FixedCustomFeeList) ProtoMessage() {}

func (x *FixedCustomFeeList) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FixedCustomFeeList.ProtoReflect.Descriptor instead.
func (*FixedCustomFeeList) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{6}
}

func (x *FixedCustomFeeList) GetFees() []*FixedCustomFee {
	if x != nil {
		return x.Fees
	}
	return nil
}

// *
// A wrapper for fee exempt key list.<br/>
// This wrapper exists to enable an update transaction to differentiate between
// a field that is not set and an empty list of keys.
// <p>
// An _unset_ field of this type SHALL NOT modify existing values.<br/>
// A _set_ field of this type with an empty `keys` list SHALL remove any
// existing values.
type FeeExemptKeyList struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A set of keys.<br/>
	// The keys in this list are permitted to submit messages to the
	// topic without paying the topic's custom fees.
	// <p>
	// If a submit transaction is signed by _any_ key included in this set,
	// custom fees SHALL NOT be charged for that transaction.
	Keys          []*Key `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeeExemptKeyList) Reset() {
	*x = FeeExemptKeyList{}
	mi := &file_custom_fees_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeeExemptKeyList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeeExemptKeyList) ProtoMessage() {}

func (x *FeeExemptKeyList) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeeExemptKeyList.ProtoReflect.Descriptor instead.
func (*FeeExemptKeyList) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{7}
}

func (x *FeeExemptKeyList) GetKeys() []*Key {
	if x != nil {
		return x.Keys
	}
	return nil
}

// *
// A maximum custom fee that the user is willing to pay.
// <p>
// This message is used to specify the maximum custom fee that given user is
// willing to pay.
type CustomFeeLimit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// *
	// A payer account identifier.
	AccountId *AccountID `protobuf:"bytes,1,opt,name=account_id,json=accountId,proto3" json:"account_id,omitempty"`
	// *
	// The maximum fees that the user is willing to pay for the message.
	Fees          []*FixedFee `protobuf:"bytes,2,rep,name=fees,proto3" json:"fees,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CustomFeeLimit) Reset() {
	*x = CustomFeeLimit{}
	mi := &file_custom_fees_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CustomFeeLimit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CustomFeeLimit) ProtoMessage() {}

func (x *CustomFeeLimit) ProtoReflect() protoreflect.Message {
	mi := &file_custom_fees_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CustomFeeLimit.ProtoReflect.Descriptor instead.
func (*CustomFeeLimit) Descriptor() ([]byte, []int) {
	return file_custom_fees_proto_rawDescGZIP(), []int{8}
}

func (x *CustomFeeLimit) GetAccountId() *AccountID {
	if x != nil {
		return x.AccountId
	}
	return nil
}

func (x *CustomFeeLimit) GetFees() []*FixedFee {
	if x != nil {
		return x.Fees
	}
	return nil
}

var File_custom_fees_proto protoreflect.FileDescriptor

const file_custom_fees_proto_rawDesc = "" +
	"\n" +
	"\x11custom_fees.proto\x12\x05proto\x1a\x11basic_types.proto\"\xc5\x01\n" +
	"\rFractionalFee\x12<\n" +
	"\x11fractional_amount\x18\x01 \x01(\v2\x0f.proto.FractionR\x10fractionalAmount\x12%\n" +
	"\x0eminimum_amount\x18\x02 \x01(\x03R\rminimumAmount\x12%\n" +
	"\x0emaximum_amount\x18\x03 \x01(\x03R\rmaximumAmount\x12(\n" +
	"\x10net_of_transfers\x18\x04 \x01(\bR\x0enetOfTransfers\"f\n" +
	"\bFixedFee\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\x03R\x06amount\x12B\n" +
	"\x15denominating_token_id\x18\x02 \x01(\v2\x0e.proto.TokenIDR\x13denominatingTokenId\"\x89\x01\n" +
	"\n" +
	"RoyaltyFee\x12G\n" +
	"\x17exchange_value_fraction\x18\x01 \x01(\v2\x0f.proto.FractionR\x15exchangeValueFraction\x122\n" +
	"\ffallback_fee\x18\x02 \x01(\v2\x0f.proto.FixedFeeR\vfallbackFee\"\xbd\x02\n" +
	"\tCustomFee\x12.\n" +
	"\tfixed_fee\x18\x01 \x01(\v2\x0f.proto.FixedFeeH\x00R\bfixedFee\x12=\n" +
	"\x0efractional_fee\x18\x02 \x01(\v2\x14.proto.FractionalFeeH\x00R\rfractionalFee\x124\n" +
	"\vroyalty_fee\x18\x04 \x01(\v2\x11.proto.RoyaltyFeeH\x00R\n" +
	"royaltyFee\x12I\n" +
	"\x18fee_collector_account_id\x18\x03 \x01(\v2\x10.proto.AccountIDR\x15feeCollectorAccountId\x129\n" +
	"\x19all_collectors_are_exempt\x18\x05 \x01(\bR\x16allCollectorsAreExemptB\x05\n" +
	"\x03fee\"\xf0\x01\n" +
	"\x11AssessedCustomFee\x12\x16\n" +
	"\x06amount\x18\x01 \x01(\x03R\x06amount\x12)\n" +
	"\btoken_id\x18\x02 \x01(\v2\x0e.proto.TokenIDR\atokenId\x12I\n" +
	"\x18fee_collector_account_id\x18\x03 \x01(\v2\x10.proto.AccountIDR\x15feeCollectorAccountId\x12M\n" +
	"\x1aeffective_payer_account_id\x18\x04 \x03(\v2\x10.proto.AccountIDR\x17effectivePayerAccountId\"\x89\x01\n" +
	"\x0eFixedCustomFee\x12,\n" +
	"\tfixed_fee\x18\x01 \x01(\v2\x0f.proto.FixedFeeR\bfixedFee\x12I\n" +
	"\x18fee_collector_account_id\x18\x02 \x01(\v2\x10.proto.AccountIDR\x15feeCollectorAccountId\"?\n" +
	"\x12FixedCustomFeeList\x12)\n" +
	"\x04fees\x18\x01 \x03(\v2\x15.proto.FixedCustomFeeR\x04fees\"2\n" +
	"\x10FeeExemptKeyList\x12\x1e\n" +
	"\x04keys\x18\x01 \x03(\v2\n" +
	".proto.KeyR\x04keys\"f\n" +
	"\x0eCustomFeeLimit\x12/\n" +
	"\n" +
	"account_id\x18\x01 \x01(\v2\x10.proto.AccountIDR\taccountId\x12#\n" +
	"\x04fees\x18\x02 \x03(\v2\x0f.proto.FixedFeeR\x04feesB&\n" +
	"\"com.hederahashgraph.api.proto.javaP\x01b\x06proto3"

var (
	file_custom_fees_proto_rawDescOnce sync.Once
	file_custom_fees_proto_rawDescData []byte
)

func file_custom_fees_proto_rawDescGZIP() []byte {
	file_custom_fees_proto_rawDescOnce.Do(func() {
		file_custom_fees_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_custom_fees_proto_rawDesc), len(file_custom_fees_proto_rawDesc)))
	})
	return file_custom_fees_proto_rawDescData
}

var file_custom_fees_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_custom_fees_proto_goTypes = []any{
	(*FractionalFee)(nil),      // 0: proto.FractionalFee
	(*FixedFee)(nil),           // 1: proto.FixedFee
	(*RoyaltyFee)(nil),         // 2: proto.RoyaltyFee
	(*CustomFee)(nil),          // 3: proto.CustomFee
	(*AssessedCustomFee)(nil),  // 4: proto.AssessedCustomFee
	(*FixedCustomFee)(nil),     // 5: proto.FixedCustomFee
	(*FixedCustomFeeList)(nil), // 6: proto.FixedCustomFeeList
	(*FeeExemptKeyList)(nil),   // 7: proto.FeeExemptKeyList
	(*CustomFeeLimit)(nil),     // 8: proto.CustomFeeLimit
	(*Fraction)(nil),           // 9: proto.Fraction
	(*TokenID)(nil),            // 10: proto.TokenID
	(*AccountID)(nil),          // 11: proto.AccountID
	(*Key)(nil),                // 12: proto.Key
}
var file_custom_fees_proto_depIdxs = []int32{
	9,  // 0: proto.FractionalFee.fractional_amount:type_name -> proto.Fraction
	10, // 1: proto.FixedFee.denominating_token_id:type_name -> proto.TokenID
	9,  // 2: proto.RoyaltyFee.exchange_value_fraction:type_name -> proto.Fraction
	1,  // 3: proto.RoyaltyFee.fallback_fee:type_name -> proto.FixedFee
	1,  // 4: proto.CustomFee.fixed_fee:type_name -> proto.FixedFee
	0,  // 5: proto.CustomFee.fractional_fee:type_name -> proto.FractionalFee
	2,  // 6: proto.CustomFee.royalty_fee:type_name -> proto.RoyaltyFee
	11, // 7: proto.CustomFee.fee_collector_account_id:type_name -> proto.AccountID
	10, // 8: proto.AssessedCustomFee.token_id:type_name -> proto.TokenID
	11, // 9: proto.AssessedCustomFee.fee_collector_account_id:type_name -> proto.AccountID
	11, // 10: proto.AssessedCustomFee.effective_payer_account_id:type_name -> proto.AccountID
	1,  // 11: proto.FixedCustomFee.fixed_fee:type_name -> proto.FixedFee
	11, // 12: proto.FixedCustomFee.fee_collector_account_id:type_name -> proto.AccountID
	5,  // 13: proto.FixedCustomFeeList.fees:type_name -> proto.FixedCustomFee
	12, // 14: proto.FeeExemptKeyList.keys:type_name -> proto.Key
	11, // 15: proto.CustomFeeLimit.account_id:type_name -> proto.AccountID
	1,  // 16: proto.CustomFeeLimit.fees:type_name -> proto.FixedFee
	17, // [17:17] is the sub-list for method output_type
	17, // [17:17] is the sub-list for method input_type
	17, // [17:17] is the sub-list for extension type_name
	17, // [17:17] is the sub-list for extension extendee
	0,  // [0:17] is the sub-list for field type_name
}

func init() { file_custom_fees_proto_init() }
func file_custom_fees_proto_init() {
	if File_custom_fees_proto != nil {
		return
	}
	file_basic_types_proto_init()
	file_custom_fees_proto_msgTypes[3].OneofWrappers = []any{
		(*CustomFee_FixedFee)(nil),
		(*CustomFee_FractionalFee)(nil),
		(*CustomFee_RoyaltyFee)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_custom_fees_proto_rawDesc), len(file_custom_fees_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_custom_fees_proto_goTypes,
		DependencyIndexes: file_custom_fees_proto_depIdxs,
		MessageInfos:      file_custom_fees_proto_msgTypes,
	}.Build()
	File_custom_fees_proto = out.File
	file_custom_fees_proto_goTypes = nil
	file_custom_fees_proto_depIdxs = nil
}
